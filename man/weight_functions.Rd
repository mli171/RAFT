% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ExampleWeights.R
\name{weight_functions}
\alias{weight_functions}
\alias{a.norm}
\alias{A.norm}
\alias{a.weib}
\alias{A.weib}
\alias{a.F}
\alias{A.F}
\alias{a.Cauchy}
\alias{A.Cauchy}
\title{Weight functions for R-estimators (score functions and derivatives)}
\usage{
A.norm(x, m, n)

a.norm(x, m, n)

A.weib(x, m, n)

a.weib(x, m, n)

A.F(x, m, n)

a.F(x, m, n)

A.Cauchy(x, m, n)

a.Cauchy(x, m, n)
}
\arguments{
\item{x}{Numeric vector with values in \eqn{[0,1]}. Interpreted as scaled ranks.}

\item{m}{Numeric. Meaning depends on the weight family:
\itemize{
\item For \code{a.F}/\code{A.F}: positive shape parameter used via \code{df1 = 2*m}.
\item For \code{a.Cauchy}/\code{A.Cauchy}: positive Cauchy scale parameter (often \eqn{\gamma}).
\item For \code{a.norm}/\code{A.norm} and \code{a.weib}/\code{A.weib}: unused (kept for a common signature).
}}

\item{n}{Numeric. Meaning depends on the weight family:
\itemize{
\item For \code{a.norm}/\code{A.norm} and \code{a.weib}/\code{A.weib}: positive finite-sample scaling parameter
(often a sample size or effective sample size used in rank scaling).
\item For \code{a.F}/\code{A.F}: positive shape parameter used via \code{df2 = 2*n}
(also appears in the closed-form expressions).
\item For \code{a.Cauchy}/\code{A.Cauchy}: unused (kept for a common signature).
}}
}
\value{
A numeric vector of the same length as \code{x}.
}
\description{
A collection of \strong{rank-based score/weight functions} \eqn{a(u)} and their
corresponding derivatives \eqn{A(u)} used in R-estimation and related estimating
equations. These functions are typically evaluated at scaled ranks
\eqn{u \in [0,1]} (including generalized ranks under censoring).
}
\details{
The functions are grouped into four families:
\itemize{
\item \strong{Normal-score (van der Waerden)}: \code{\link{a.norm}}, \code{\link{A.norm}}
\item \strong{Weibull/log-type}: \code{\link{a.weib}}, \code{\link{A.weib}}
\item \strong{F-quantile-based}: \code{\link{a.F}}, \code{\link{A.F}}
\item \strong{Cauchy-type (sine-based)}: \code{\link{a.Cauchy}}, \code{\link{A.Cauchy}}
}

\strong{Normal-score family}

Uses the finite-sample mapping
\deqn{z(u) = \Phi^{-1}\left(\frac{n u + 0.5}{n+1}\right)}
and returns:
\itemize{
\item \code{a.norm(u)} = \eqn{z(u)}
\item \code{A.norm(u)} = \eqn{-\frac{n+1}{n}\,\phi(z(u))}
}
where \eqn{\Phi^{-1}} is the standard normal quantile and \eqn{\phi} its density.

\strong{Weibull/log-type family}

Uses \eqn{t(u) = 1 - n u/(n+1)} and returns:
\itemize{
\item \code{a.weib(u)} = \eqn{-1 - \log(t(u))}
\item \code{A.weib(u)} = \eqn{\frac{n+1}{n}\,t(u)\,\log(t(u))}
}

\strong{F-quantile family}

Uses the F-quantile \eqn{F^{-1}(u)} computed by \code{qf(u, df1 = 2*m, df2 = 2*n)}.
Since \eqn{F^{-1}(1)=\infty}, this implementation \strong{guards against \code{x == 1}}
by substituting \code{F.inv = 0} when \code{x == 1}, returning a finite value.
In typical rank workflows, \code{x} should avoid being exactly 1.

\strong{Cauchy family}

Sine-based scores parameterized by a positive scale \code{m}:
\itemize{
\item \code{a.Cauchy(u)} = \eqn{-\sin(2\pi u)/m}
\item \code{A.Cauchy(u)} = \eqn{-\sin^2(\pi u)/m}
}
}
\examples{
u <- seq(0.01, 0.99, length.out = 5)

# Normal scores
a.norm(u, m = NA, n = 100)
A.norm(u, m = NA, n = 100)

# Weibull/log-type
a.weib(u, m = NA, n = 100)
A.weib(u, m = NA, n = 100)

# F-based
a.F(u, m = 2, n = 5)
A.F(u, m = 2, n = 5)

# Cauchy-type
a.Cauchy(u, m = 1, n = NA)
A.Cauchy(u, m = 1, n = NA)

}
