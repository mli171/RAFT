#' Simulate example right-censored data from an AFT model
#'
#' Generates synthetic data from a accelerated failure time (AFT) linear model
#' with right-censoring:
#' \deqn{Y_i^* = x_i^\top \beta + \varepsilon_i,}
#' where \eqn{\varepsilon_i} is generated by applying an inverse/quantile-type
#' function \code{F.inv} to uniforms, and observed outcomes are
#' \deqn{Y_i = \min(Y_i^*, C_i), \qquad \delta_i = I(Y_i^* \le C_i).}
#'
#' Covariates include a Bernoulli indicator \code{x.1} and a Gaussian covariate
#' \code{x.2} whose mean can depend on \code{x.1} via \code{alpha}. The censoring
#' time \eqn{C_i} is normal with mean \code{mu.c} and sd \code{sd.c}, optionally
#' shifted by \code{gamma * x.1}.
#'
#' User can modify this function for future simulation need.
#'
#' @param n.data Integer. Sample size \eqn{n}.
#' @param beta Numeric vector of regression coefficients. Length must match the
#'   number of columns of \code{x} (currently 2).
#' @param sd.y Positive numeric. Scale parameter passed to \code{F.inv} when
#'   generating the error term \eqn{\varepsilon_i}.
#' @param mu.c Numeric. Mean of the censoring-time distribution (baseline).
#' @param sd.c Positive numeric. Standard deviation of the censoring-time distribution.
#' @param alpha Numeric. Controls dependence of \code{x.2} on \code{x.1}:
#'   \code{x.2 = rnorm(...) + 1 + alpha*(x.1 - 0.5)}.
#' @param gamma Numeric. Controls dependence of censoring on \code{x.1}:
#'   \code{c.star = rnorm(...) + gamma*x.1}.
#' @param F.inv Function. Inverse/quantile mapping used to generate model errors.
#'   It must accept arguments \code{(u, sd.y)} where \code{u} is a numeric vector of
#'   uniforms in \eqn{(0,1)} and \code{sd.y} is a scale parameter. Default is
#'   \code{Q.norm} (assumed to be defined elsewhere in the package).
#' @param seed Optional integer random seed for reproducible simulation.
#'   If \code{NULL}, the current RNG state is used.
#'
#' @return A list with components:
#' \itemize{
#'   \item \code{y}: observed outcome \eqn{Y = \min(Y^*, C)}.
#'   \item \code{delta}: event indicator \eqn{\delta = I(Y^* \le C)} (1 = uncensored).
#'   \item \code{x}: \eqn{n \times 2} covariate matrix (centered by column means).
#'   \item \code{y.star}: latent (uncensored) outcome \eqn{Y^*}.
#' }
#'
#' @details
#' \strong{Covariate generation}
#' \itemize{
#'   \item \code{x.1} is Bernoulli(0.5).
#'   \item \code{x.2} is normal with mean \code{1 + alpha*(x.1 - 0.5)} and sd 1.
#'   \item The matrix \code{x} is column-centered: \code{x <- x - rep(colMeans(x), each = n.data)}.
#' }
#'
#' \strong{Censoring generation}
#' \itemize{
#'   \item \code{c.star} is normal with mean \code{mu.c + gamma*x.1} and sd \code{sd.c}.
#' }
#'
#' \strong{Reproducibility note}
#' The function references \code{seed} internally. As written, \code{seed} is not an
#' argument; it must exist in the calling environment for \code{set.seed(seed)} to run.
#' A more robust pattern is to add \code{seed = NULL} to the function signature.
#'
#' @examples
#' \dontrun{
#' # Assuming Q.norm(u, sd.y) is defined, e.g.:
#' # Q.norm <- function(u, sd.y) qnorm(u, mean = 0, sd = sd.y)
#'
#' dat <- generate.aft(n.data = 200, beta = c(0.5, -0.25), sd.y = 1,
#'                     mu.c = 1.5, sd.c = 2, alpha = 0.3, gamma = 0.5)
#'
#' }
#'
#' @export
generate.aft = function(n.data=100, beta=c(0,0), sd.y=1, mu.c=1.5, sd.c=2, alpha=0, gamma=0, F.inv=Q.norm, seed=NULL) {

  if (!is.null(seed)) set.seed(seed)

  x.1  = rbinom(n.data,size=1, prob=0.5)
  x.2  = rnorm(n.data,mean=0, sd=1) + 1 + alpha*(x.1-0.5)
  x    = cbind(x.1,x.2)
  mu.x = colMeans(x)
  x    = x-rep(mu.x, each=n.data)

  mu.y =as.vector( x %*% beta )

  u      = runif(n.data)
  y.star = mu.y + F.inv(u, sd.y)
  c.star = rnorm(n.data, mean=mu.c, sd=sd.c) + gamma*x.1

  y     = pmin(y.star,c.star)
  delta = ifelse(y==y.star,1,0)

  res = list(y=y, delta=delta, x=x, y.star=y.star)
  return(res)

}
